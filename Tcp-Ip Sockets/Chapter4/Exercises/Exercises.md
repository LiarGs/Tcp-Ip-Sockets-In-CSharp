# TCP/IP Sockets 学习笔记

## 1. 迭代服务器 vs. 并发服务器 (Iterative vs. Multiprocessing)

**核心问题：** 在什么精确的条件下，使用迭代服务器（Iterative Server）会比使用多处理/并发服务器（Multiprocessing Server）更好？

### 结论

只有当以下**两个条件同时满足**时，迭代服务器才是首选：

1. **服务时间极短 (Short Service Time):** 处理每个客户端请求所需的时间非常少（例如仅做简单的内存查询或计算）。
2. **请求频率较低 (Low Arrival Rate):** 客户端发起连接的频率不高。

### 详细解析

* **原理：**  **迭代服务器**（如 `TcpEchoServer.cs`）一次只能处理一个连接。如果有新请求进来，它必须在系统队列（Backlog）中等待。
    * **并发服务器**（如 `TcpEchoServerThread.cs`）为每个请求创建新线程/进程。
* **权衡 (Trade-off):** * 创建线程或进程有显著的 CPU 和内存**开销 (Overhead)**。
    * 如果处理一个请求只需要几微秒（$\mu s$），而启动一个线程需要几毫秒（$ms$），那么并发模型的开销反而大于业务本身的价值。
    * 此外，迭代服务器避免了复杂的同步锁（Locks/Mutexes）问题，开发和调试更简单。

---

## 2. TCP 客户端/服务器的超时设置 (Timeouts)

**核心问题：** 既然 TCP 是可靠传输协议，我们是否还需要在客户端或服务器中实现超时机制？

### 结论

**是，绝对需要。** 手动实现应用层超时是构建健壮网络程序的强制性要求。

### 三大核心理由

1. **检测“死连接” (Dead Peers):**
    * **场景：** 对端主机突然断电、崩溃或网线被拔，无法发送 `FIN` 或 `RST` 包。
    * **后果：** 如果没有超时，`Receive()` 方法会无限期阻塞，导致线程永久挂起（Zombie Thread）。
    * **代码示例：** 参考 `TcpEchoServerTimeout.cs` 中的 `client.SetSocketOption(..., ReceiveTimeout, ...)`。

2. **防御资源耗尽攻击 (DoS Protection):**
    * **场景：** 恶意客户端建立连接后故意不发送数据，或者以极慢的速度发送（Slowloris 攻击）。
    * **后果：** 服务器的线程池或 Socket 句柄资源会被耗尽，导致无法服务正常用户。

3. **用户体验 (User Experience):**
    * **场景：** 网络极差导致丢包。
    * **后果：** 操作系统底层的 TCP 重传超时通常长达数分钟。应用层设置较短的超时（如 5 秒）可以让程序快速报错（"Fail Fast"
      ），允许用户尽快重试，而不是让界面卡死。